/**
 * @file test_nexys4io.c
 *
 * @author Roy Kravitz (roy.kravitz@pdx.edu), modified for ECE 544 Project #1
 * @copyright Portland State University, 2024
 *
 * @brief
 * This program implements the required functionality for Project #1 in ECE 544.
 * It allows control of RGB1 LED using pushbuttons and displays duty cycles on the
 * 7-segment display while mirroring RGB1 settings to RGB2.
 *
 ******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xstatus.h"
#include "microblaze_sleep.h"
#include "xtmrctr.h"
#include "xintc.h"
#include "nexys4IO.h"

#define CPU_CLOCK_FREQ_HZ        XPAR_CPU_CORE_CLOCK_FREQ_HZ
#define FIT_INTR_NUM             XPAR_MICROBLAZE_0_AXI_INTC_FIT_TIMER_0_INTERRUPT_INTR
#define N4IO_DEVICE_ID           XPAR_NEXYS4IO_0_DEVICE_ID
#define N4IO_BASEADDR            XPAR_NEXYS4IO_0_S00_AXI_BASEADDR
#define INTC_DEVICE_ID           XPAR_INTC_0_DEVICE_ID

// AXI Timer parameters
#define N4IO_PWM_CLK_DEVICE_ID   XPAR_TMRCTR_0_DEVICE_ID
#define N4IO_PWM_CLK_BASEADDR    XPAR_TMRCTR_0_BASEADDR
#define N4IO_PWM_CLK_HIGHADDR    XPAR_TMRCTR_0_HIGHADDR
#define N4IO_PWM_CLK_FREQ_HZ     XPAR_TMRCTR_0_CLOCK_FREQ_HZ
#define N4IO_PWM_CLK_TIMER_NUM   0
#define N4IO_PWM_CLK_TIMER_VAL   1998

// Duty cycle min/max
#define DUTY_CYCLE_MIN 0
#define DUTY_CYCLE_MAX 99

// Global Variables
volatile uint8_t redDC = 0, greenDC = 0, blueDC = 0;
volatile bool newbtnsSw = false;
volatile uint16_t sw = 0;
volatile uint8_t btns = 0;

XTmrCtr N4IO_TimerInst;
XIntc INTC_Inst;

// Function Prototypes
void FIT_Handler(void);
int do_init(void);
int N4IO_RGB_timer_initialize(void);
void updateRGB1DutyCycle(void);
void update7SegmentDisplay(void);
uint8_t swizzleBtns(uint8_t btns);
void nexys4io_selfTest(void);

int main() {
    xil_printf("ECE 544 Nexys4IO Project #1 Application\r\n");
    init_platform();
    uint8_t CRateR = 0;
    uint8_t CRateG = 0;
    uint8_t CRateB = 0;
    if (do_init() != XST_SUCCESS) {
        xil_printf("Initialization failed!\r\n");
        return 1;
    }

    microblaze_enable_interrupts();
    nexys4io_selfTest();

    while (1) {
        if (newbtnsSw) {
            NX4IO_setLEDs(sw);
            if (_DEBUG) xil_printf("\nNew switches: 0x%04X\tNew buttons: 0x%02X\n\n", sw, btns);

            // Check each button and update the corresponding LED duty cycle
            if (btns & 0x08) {  // BTND (BTN3) -> RED LED
				if (_DEBUG) xil_printf("BTND Pressed...\n");
                CRateR = (CRateR + 25) % 125;  // Ensures it resets after exceeding 100
				if (_DEBUG) xil_printf("Adjusting RGB1 RED LED...\n");
            }

            if (btns & 0x01) {  // BTNU (BTN0) -> GREEN LED
				if (_DEBUG) xil_printf("BTNU Pressed...\n");
                CRateG = (CRateG + 25) % 125;
				if (_DEBUG) xil_printf("Adjusting RGB1 GREEN LED...\n");
            }

            if (btns & 0x02) {  // BTNR (BTN1) -> BLUE LED
				if (_DEBUG) xil_printf("BTNR Pressed...\n");
                CRateB = (CRateB + 25) % 125;
				if (_DEBUG) xil_printf("Adjusting RGB1 BLUE LED...\n");
				uint32_t rgb1_status = NX4IO_RGBLED_getRGB_DATA(RGB1);
				xil_printf("RGB1 Status: 0x%08X\n", rgb1_status);

            }

			if (btns & 0x04) {  // BTNL (BTN2) -> RESET ALL LEDS
				if (_DEBUG) xil_printf("BTNL Pressed...\n");
                //NX4IO_SSEG_setDecPt(SSEGHI, DIGIT6, true);
                CRateR = 0;
                CRateG = 0;
                CRateB = 0;
				if (_DEBUG) xil_printf("Resetting RGB1...\n");
            }

            // Update the RGB1 LED with new duty cycle values
            NX4IO_RGBLED_setDutyCycle(RGB2, CRateR, CRateG, CRateB);
        	usleep(2000 * 1000);
			if (_DEBUG) xil_printf("CRateR: %d \t CRateG: %d CRateB: %d \t \n",CRateR, CRateG, CRateB);

            newbtnsSw = false; // Reset flag after processing
        }
    }
    return 0;
}

void FIT_Handler(void) {
    static uint8_t prevBtns = 0x0F;
    static uint16_t prevSw = 0xFFFF;
    static bool dpOn = false;

    uint8_t btns_int = NX4IO_getBtns();
    btns = swizzleBtns(btns_int);

    if (btns != prevBtns) {
        if (btns & NEXYS4IO_BTNR_MASK) blueDC = (blueDC + 10) % (DUTY_CYCLE_MAX + 1);
        if (btns & NEXYS4IO_BTNU_MASK) greenDC = (greenDC + 10) % (DUTY_CYCLE_MAX + 1);
        if (btns & NEXYS4IO_BTND_MASK) redDC = (redDC + 10) % (DUTY_CYCLE_MAX + 1);
        if (btns & NEXYS4IO_BTNL_MASK) redDC = greenDC = blueDC = DUTY_CYCLE_MIN;

        updateRGB1DutyCycle();
        prevBtns = btns;
    }

    sw = NX4IO_getSwitches();
    if (sw != prevSw) {
        newbtnsSw = true;
        prevSw = sw;
    }

    dpOn = !dpOn;
    NX4IO_SSEG_setDecPt(SSEGLO, DIGIT0, dpOn);
}

void updateRGB1DutyCycle() {
    //NX4IO_RGBLED_setDutyCycle(RGB1, redDC, greenDC, blueDC);
    //usleep(2000 * 1000);
    NX4IO_RGBLED_setDutyCycle(RGB2, redDC, greenDC, blueDC);
	usleep(2000 * 1000);
}

void update7SegmentDisplay() {
    NX4IO_SSEG_putU32Dec(((uint32_t)redDC << 16) | ((uint32_t)greenDC << 8) | (uint32_t)blueDC, true);
}

uint8_t swizzleBtns(uint8_t btns) {
    return ((btns & 0x10) >> 3) | ((btns & 0x08) >> 1) | ((btns & 0x04) << 1) | ((btns & 0x02) << 3);
}

int  N4IO_RGB_timer_initialize(void) {
	uint32_t status;	// status from Xilinx Lib calls

	status = XTmrCtr_Initialize(&N4IO_TimerInst,N4IO_PWM_CLK_DEVICE_ID);
    if (status != XST_SUCCESS) {
        return XST_FAILURE;
    }
	status = XTmrCtr_SelfTest(&N4IO_TimerInst, N4IO_PWM_CLK_TIMER_NUM);
    if (status != XST_SUCCESS) {
			return XST_FAILURE;
    }

	// Configure the timer
	// We are going to use the low level functions because there doesn't
	// seem to be a configuration option that enables the Generate Out options
	// and load an initial timer value.  This code comes from xtrctr_low_level_example
	uint32_t ctl = XTC_CSR_AUTO_RELOAD_MASK |  XTC_CSR_DOWN_COUNT_MASK |  XTC_CSR_EXT_GENERATE_MASK;

	XTmrCtr_SetControlStatusReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, (ctl | XTC_CSR_LOAD_MASK));
	XTmrCtr_SetLoadReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, N4IO_PWM_CLK_TIMER_VAL);
	XTmrCtr_LoadTimerCounterReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM);
	XTmrCtr_SetControlStatusReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, (ctl & ~XTC_CSR_LOAD_MASK));

	// and start it
	XTmrCtr_Start(&N4IO_TimerInst, N4IO_PWM_CLK_TIMER_NUM);
	return XST_SUCCESS;
}

int do_init() {
    if (N4IO_RGB_timer_initialize() != XST_SUCCESS) return XST_FAILURE;
    if (NX4IO_initialize(N4IO_BASEADDR) != XST_SUCCESS) return XST_FAILURE;
    if (XIntc_Initialize(&INTC_Inst, INTC_DEVICE_ID) != XST_SUCCESS) return XST_FAILURE;
    if (XIntc_Connect(&INTC_Inst, FIT_INTR_NUM, (XInterruptHandler)FIT_Handler, NULL) != XST_SUCCESS) return XST_FAILURE;
    if (XIntc_Start(&INTC_Inst, XIN_REAL_MODE) != XST_SUCCESS) return XST_FAILURE;
    XIntc_Enable(&INTC_Inst, FIT_INTR_NUM);
    return XST_SUCCESS;
}

void nexys4io_selfTest(void) {
	xil_printf("Starting Nexys4IO self test...\r\n");

	xil_printf("\tcheck functionality of LEDs\r\n");
	uint16_t ledvalue = 0x0001;
	do {
		NX4IO_setLEDs(ledvalue);
		usleep(250 * 1000);
		ledvalue = ledvalue << 1;
	} while (ledvalue != 0);

	xil_printf("\tcheck functionality of 7-segment display\r\n");
	// set the display digits to -ECE544- and turn off
	// the decimal points using the "raw" set functions.
	NX4IO_SSEG_setSSEG_DATA(SSEGHI, 0x0058E30E);
	NX4IO_SSEG_setSSEG_DATA(SSEGLO, 0x00144116);
	usleep(2000 * 1000);

	xil_printf("\tcheck functionality of the RGB2 LED\n\r");
	// RGB2 is controlled by Nexys4IO
	NX4IO_RGBLED_setChnlEn(RGB2, true, true, true);
	xil_printf("\t\tRGB2 segments set to {{99%%, 00%%, 00%%} duty cycle - display RED\n\r");
	NX4IO_RGBLED_setDutyCycle(RGB2, 255, 0, 0);
	usleep(2000 * 1000);

	xil_printf("\t\tRGB2 segments set to {{00%%, 50%%, 00%%} duty cycle - display Green\n\r");
	NX4IO_RGBLED_setDutyCycle(RGB2, 0, 255, 0);
	usleep(2000 * 1000);

	xil_printf("\t\tRGB2 segments set to {{00%%, 00%%, 25%%} duty cycle - display Blue\n\r");
	NX4IO_RGBLED_setDutyCycle(RGB2, 0, 0, 64);
	usleep(2000 * 1000);

	xil_printf("\t\tRGB2 segments set to {{50%%, 12%%, 25%%} duty cycle - display Purplish-ish\n\r");
    NX4IO_RGBLED_setDutyCycle(RGB2, 255, 32, 64);
	usleep(2000 * 1000);


	// turn off LEDs, display and RGB LEDs
	NX410_SSEG_setAllDigits(SSEGLO, CC_BLANK, CC_BLANK, CC_BLANK, CC_BLANK, DP_NONE);
	NX410_SSEG_setAllDigits(SSEGHI, CC_BLANK, CC_BLANK, CC_BLANK, CC_BLANK, DP_NONE);
    NX4IO_setLEDs(0x0000);

	// Turn off RGB2
	NX4IO_RGBLED_setDutyCycle(RGB2, 1, 1, 1);
	xil_printf("...Nexys4IO self test complete\r\n");
	return;
 }

