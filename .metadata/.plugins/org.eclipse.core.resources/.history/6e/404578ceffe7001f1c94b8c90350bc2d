/**
 * @file test_nexys4ioV2.c
 *
 * @author Phil Nevins (p.nevins971@gmail.com)
 * @copyright Phil Nevins 2025
 *
 * @brief
 * Built off Roy Kravitz test_nexys4io.c application
 *
 * This program tests the Nexys4IO peripheral and driver in an embedded system
 * running on a MicroBlaze processor. It configures and manages the RGB LED PWM
 * clock, handles button and switch inputs, and displays output on the 7-segment
 * display and LEDs. The program also includes an interrupt-driven mechanism to
 * continuously update and synchronize switch and button states.
 *
 * The system operates as follows:
 * - Initializes the RGB LED PWM clock using an AXI timer.
 * - Reads and processes button and switch inputs.
 * - Displays button states using decimal points on the 7-segment display.
 * - Displays switch states using LEDs.
 * - Reads PWM duty cycle values from an external Digilent PWM Analyzer.
 * - Updates the RGB LEDs based on button presses and PWM Analyzer values.
 * - Uses a Fixed Interval Timer (FIT) interrupt handler to periodically update states.
 *
 * @note
 * This implementation supports both Nexys A7 and the Boolean board.
 * The mapping of pushbuttons is:
 *
 *                o BTNU(BTN0)
 *
 * BTNL(BTN2) o       o BTNR(BTN1)
 *
 *                o BTND(BTN3)
 *
 * The button vector format is {BTND(BTN3), BTNL(BTN2), BTNR(BTN1), BTNU(BTN0)}
 *
 * <pre>
 * MODIFICATION HISTORY:
 * ---------------------
 * Ver   Who  Date       Changes
 * ----- ---- ---------- -----------------------------------------------
 * 1.00a  RK  21-Dec-2022 Initial release
 * 2.00a  RK  24-Jan-2024 Support for both Nexys A7 and Boolean boards
 * V2.00  PN  9-Feb-2025  Refactored for ECE 544 Project 1 with PWM Analyzer support
 * </pre>
 *
 ******************************************************************************/


/*********** Include Files **********/
#include <stdio.h>
#include <stdlib.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xstatus.h"
#include "microblaze_sleep.h"
#include "xil_io.h" //Added Code - Needed for reading/writing AXI registers
#include "xtmrctr.h"
#include "xintc.h"
#include "nexys4IO.h"
#include "PWM_Analyzer.h"

/********** DEBUG OUTPUT FLAG **********/
#define _DEBUG  					1		// 1 - Debug on. 0 - Debug off

/*********** Peripheral-related constants **********/
// Clock frequencies
#define CPU_CLOCK_FREQ_HZ			XPAR_CPU_CORE_CLOCK_FREQ_HZ
#define AXI_CLOCK_FREQ_HZ			XPAR_CPU_M_AXI_DP_FREQ_HZ

// AXI timer parameters (used to set Nexys4IO RGB Clock period)
// Timing Interval = (1998 + 2) * (1/10MHz) -> 50 KHz/PWM Period * 512) => 98Hz
#define N4IO_PWM_CLK_DEVICE_ID		XPAR_TMRCTR_0_DEVICE_ID
#define N4IO_PWM_CLK_BASEADDR		XPAR_TMRCTR_0_BASEADDR
#define N4IO_PWM_CLK_HIGHADDR		XPAR_TMRCTR_0_HIGHADDR
#define N4IO_PWM_CLK_FREQ_HZ 		XPAR_TMRCTR_0_CLOCK_FREQ_HZ
#define N4IO_PWM_CLK_TIMER_NUM		0
#define N4IO_PWM_CLK_TIMER_VAL		1998

// Definitions for peripheral NEXYS4IO
#define N4IO_DEVICE_ID		   		XPAR_NEXYS4IO_0_DEVICE_ID
#define N4IO_BASEADDR		    	XPAR_NEXYS4IO_0_S00_AXI_BASEADDR
#define N4IO_HIGHADDR		    	XPAR_NEXYS4IO_0_S00_AXI_HIGHADDR

// Definitions for Fixed Interval timer - 100 MHz input clock, 2Hz output clock
// Used as interval to handle the slide switches and pushbuttons
#define FIT_IN_CLOCK_FREQ_HZ		XPAR_CPU_CORE_CLOCK_FREQ_HZ
#define FIT_CLOCK_FREQ_HZ			2
#define FIT_INTR_NUM				XPAR_MICROBLAZE_0_AXI_INTC_FIT_TIMER_0_INTERRUPT_INTR

//Definitions for Interrupt Controller
#define INTC_DEVICE_ID				XPAR_INTC_0_DEVICE_ID
#define INTC_BASEADDR				XPAR_INTC_0_BASEADDR
#define INTC_HIGHADDR				XPAR_INTC_0_HIGHADDR


//Added Code - Define base addresses for the Digilent PWM Analyzer IP
#define PWM_ANALYZER_RED_BASE  		XPAR_PWM_ANALYZER_0_S00_AXI_BASEADDR
#define PWM_ANALYZER_GREEN_BASE 	XPAR_PWM_ANALYZER_1_S00_AXI_BASEADDR
#define PWM_ANALYZER_BLUE_BASE 		XPAR_PWM_ANALYZER_2_S00_AXI_BASEADDR

/*********** Application-specific constants **********/
#define NBTNS 			4		// number of buttons

/********** AXI Peripheral Instances **********/
XTmrCtr		N4IO_TimerInst;	// Timer instance for N4IO rgb clock input
XIntc 		INTC_Inst;		// Interrupt Controller instance


/********** Global Variables **********/
// These are volatile because they are generated in the FIT handler which is asynchronous
// to the program. We want to make sure the current values of the variables are returned
volatile bool newbtnsSw = false; // true if the FIT handler updated global buttons and switch values
volatile uint16_t sw = 0;	// switches - set in the FIT handler
volatile uint8_t btns = 0;	// buttons - set in the FIT handler


/********** Function Prototypes **********/
// interrupt handlers
void FIT_Handler(void);

// initialization functions
int  N4IO_RGB_timer_initialize(void);
int	 do_init(void);

// other functions
uint8_t swizzleBtns(uint8_t btns);
void nexys4io_selfTest(void);

// Added Code - Variables
uint8_t CRateR = 0;
uint8_t CRateG = 0;
uint8_t CRateB = 0;

/********** Main Program **********/
int main()	{


    // Announce that the application has started
		if (_DEBUG) xil_printf("Starting App in DEBUG mode...\n");
	xil_printf("ECE 544 Nexys4IO Project 1\r\n");
    xil_printf("By Phil Nevins (p.nevins971@gmail.com)\r\n\n");

    init_platform();
    uint32_t sts = do_init();
    if (XST_SUCCESS != sts){
        xil_printf("FATAL(main): System initialization failed\r\n");
        return 1;
    }

    // Perform the self test
    microblaze_disable_interrupts();
		if (_DEBUG) xil_printf("Disabled Microblaze Interrupts...\n\n");

		if (_DEBUG) xil_printf("Running nexys4io_selfTest()...\n\n");
    nexys4io_selfTest();
		if (_DEBUG) xil_printf("nexys4io_selfTest() complete!\n\n");

    microblaze_enable_interrupts();
		if (_DEBUG) xil_printf("Enabled Microblaze Interrupts...\n\n");

	// Main loop
		if (_DEBUG) xil_printf("Entering Main Loop...\n\n");
    while (1) {
        if (newbtnsSw) {
            NX4IO_setLEDs(sw);
            if (_DEBUG) xil_printf("\nNew switches: 0x%04X\tNew buttons: 0x%02X\n\n", sw, btns);

            // Check each button and update the corresponding LED duty cycle
            if (btns & 0x08) {  // BTND (BTN3) -> RED LED
				if (_DEBUG) xil_printf("BTND Pressed...\n");
                CRateR = (CRateR + 25) % 125;  // Ensures it resets after exceeding 100
				if (_DEBUG) xil_printf("Adjusting RGB1 RED LED...\n");
            }

            if (btns & 0x01) {  // BTNU (BTN0) -> GREEN LED
				if (_DEBUG) xil_printf("BTNU Pressed...\n");
                CRateG = (CRateG + 25) % 125;
				if (_DEBUG) xil_printf("Adjusting RGB1 GREEN LED...\n");
            }

            if (btns & 0x02) {  // BTNR (BTN1) -> BLUE LED
				if (_DEBUG) xil_printf("BTNR Pressed...\n");
                CRateB = (CRateB + 25) % 125;
				if (_DEBUG) xil_printf("Adjusting RGB1 BLUE LED...\n");
				uint32_t rgb1_status = NX4IO_RGBLED_getRGB_DATA(RGB1);
				xil_printf("RGB1 Status: 0x%08X\n", rgb1_status);

            }

			if (btns & 0x04) {  // BTNL (BTN2) -> RESET ALL LEDS
				if (_DEBUG) xil_printf("BTNL Pressed...\n");
                //NX4IO_SSEG_setDecPt(SSEGHI, DIGIT6, true);
                CRateR = 0;
                CRateG = 0;
                CRateB = 0;
				if (_DEBUG) xil_printf("Resetting RGB1...\n");
            }

            // Update the RGB1 LED with new duty cycle values
            NX4IO_RGBLED_setDutyCycle(RGB2, CRateR, CRateG, CRateB);
        	usleep(2000 * 1000);
			if (_DEBUG) xil_printf("CRateR: %d \t CRateG: %d CRateB: %d \t \n",CRateR, CRateG, CRateB);

            newbtnsSw = false; // Reset flag after processing
        }
    }  // End of While

    // Clean up and exit
    microblaze_disable_interrupts();
    NX410_SSEG_setAllDigits(SSEGHI, CC_BLANK, CC_B, CC_LCY, CC_E, DP_NONE);
    NX410_SSEG_setAllDigits(SSEGLO, CC_B, CC_LCY, CC_E, CC_BLANK, DP_NONE);
    xil_printf("ECE 544 Nexys4IO Test Program...ending\r\n");
    cleanup_platform();
    return 0;
} // End of Main



/********** Interrupt Handlers **********/

/****************************************************************************/
/**
* Fixed interval timer interrupt handler
*
* Reads the switches and sets the handshaking signal if any changes.
* Reads the button and sets the handshaking signal if any changes.
* Checks/sets the global newbtnsSw which is the handshake between the interrupt handler and main
*
* @note:  pushbutton mapping: {0 0 0 btnC btnU btnD btnL btnR}
*
* @note  This handler should be called about twice per second
*****************************************************************************/
void FIT_Handler(void)
{
    static bool isInitialized = false;  // true if the function has run at least once
    static uint8_t prevBtns;            // previous value of button register
    static uint16_t prevSw;             // previous value of the switch register
    static bool dpOn;                    // true if decimal point 0 is on

    uint8_t btns_int;                    // temp btns. Needs to be swizzled to get bits in right place for main()



    // Initialize the static variables the first time the function is called
    if (!isInitialized) {

        prevBtns = 0x0F;    // Invert btns to get everything started
        prevSw = 0xFFFF;    // Invert switches to get everything started
        dpOn = true;
        isInitialized = true;
    }

    // Toggle DP0 to indicate that FIT handler is being called
    dpOn = !dpOn;
    NX4IO_SSEG_setDecPt(SSEGLO, DIGIT0, dpOn);


    // Return if main() hasn't handled the last button and switch changes
    if (newbtnsSw) {
        return;
    }

    // Get the value of the switches
    sw = NX4IO_getSwitches();


    if (prevSw != sw) {
        newbtnsSw = true;
        prevSw = sw;

    }

    // Get the value of the buttons
    btns_int = NX4IO_getBtns();
    btns = swizzleBtns(btns_int);


    if (prevBtns != btns) {
        newbtnsSw = true;
        prevBtns = btns;
    }

    /********** Read PWM Duty Cycles from Analyzer **********/

    int pwm_red = PWM_Analyzer_GetDutyCycle_percent(XPAR_PWM_ANALYZER_2_S00_AXI_BASEADDR);

    //uint8_t pwm_green = Xil_In8(XPAR_PWM_ANALYZER_1_S00_AXI_BASEADDR);
    //uint8_t pwm_blue = Xil_In8(XPAR_PWM_ANALYZER_2_S00_AXI_BASEADDR);


    //if (_DEBUG) xil_printf("FIT_Handler: PWM values - Red: %d, Green: %d, Blue: %d\n", pwm_red, pwm_green, pwm_blue);

    /********** Set RGB2 LED to match detected PWM **********/
    //NX4IO_RGBLED_setDutyCycle(RGB2, pwm_red, pwm_green, pwm_blue);


    /********** Display Duty Cycle Values on 7-Segment Display **********/

    NX4IO_SSEG_setDigit(SSEGHI, DIGIT7, (enum _NX4IO_charcodes)(pwm_red / 10));  // Tens place of RED duty cycle
    NX4IO_SSEG_setDigit(SSEGHI, DIGIT6, (enum _NX4IO_charcodes)(pwm_red % 10));  // Ones place of RED duty cycle
    NX4IO_SSEG_setDigit(SSEGHI, DIGIT5, CC_BLANK);  // Leave digit 5 blank
    NX4IO_SSEG_setDigit(SSEGHI, DIGIT4, (enum _NX4IO_charcodes)(CRateG / 10)); // Tens place of GREEN duty cycle
    NX4IO_SSEG_setDigit(SSEGLO, DIGIT3, (enum _NX4IO_charcodes)(CRateG % 10)); // Ones place of GREEN duty cycle
    NX4IO_SSEG_setDigit(SSEGLO, DIGIT2, CC_BLANK);  // Leave digit 2 blank
    NX4IO_SSEG_setDigit(SSEGLO, DIGIT1, (enum _NX4IO_charcodes)(CRateB / 10));  // Tens place of BLUE duty cycle
    NX4IO_SSEG_setDigit(SSEGLO, DIGIT0, (enum _NX4IO_charcodes)(CRateB % 10));  // Ones place of BLUE duty cycle


}



/********** Initialization functions **********/

/****************************************************************************/
/**
 * N4IO_RGB_timer_initialize() - initializes the Nexys4IO rgbPWM clock timer
 *
 * @brief The Nexys4 IO IP block has an independant clock input for the 3 channel
 * PWM generator for the two RGB LEDs on the Nexys A7.  In the MicroBlaze-based
 * system used for this project that clock is generated by an AXI programmable
 * interval timer.  This function initializes the timer, runs the self test and
 * configures and starts the timer.
 *
 * @return			XST_Success if the timer is initialized.  XST_FAILURE if it is not
 */
int  N4IO_RGB_timer_initialize(void) {
					if (_DEBUG) xil_printf("Entering N410_RGB_timer_initialize...");

	uint32_t status;	// status from Xilinx Lib calls

	status = XTmrCtr_Initialize(&N4IO_TimerInst,N4IO_PWM_CLK_DEVICE_ID);
    if (status != XST_SUCCESS) {
        return XST_FAILURE;
    }
	status = XTmrCtr_SelfTest(&N4IO_TimerInst, N4IO_PWM_CLK_TIMER_NUM);
    if (status != XST_SUCCESS) {
			return XST_FAILURE;
    }

	// Configure the timer
	// We are going to use the low level functions because there doesn't
	// seem to be a configuration option that enables the Generate Out options
	// and load an initial timer value.  This code comes from xtrctr_low_level_example

	uint32_t ctl = XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_DOWN_COUNT_MASK | XTC_CSR_EXT_GENERATE_MASK;

		if (_DEBUG) xil_printf("N410_RGB_timer_initialize - ctl = %X (AUTO_RELOAD: %X, DOWN_COUNT: %X, EXT_GENERATE: %X)\n",
                ctl, XTC_CSR_AUTO_RELOAD_MASK, XTC_CSR_DOWN_COUNT_MASK, XTC_CSR_EXT_GENERATE_MASK);

		if (_DEBUG) xil_printf("Setting Control Status Register: BaseAddr = %X, TimerNum = %d, Value = %X (with LOAD_MASK)\n",
                N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, (ctl | XTC_CSR_LOAD_MASK));

	XTmrCtr_SetControlStatusReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, (ctl | XTC_CSR_LOAD_MASK));

		if (_DEBUG) xil_printf("Setting Load Register: BaseAddr = %X, TimerNum = %d, Value = %X\n",
                N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, N4IO_PWM_CLK_TIMER_VAL);

	XTmrCtr_SetLoadReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, N4IO_PWM_CLK_TIMER_VAL);

		if (_DEBUG) xil_printf("Loading Timer Counter Register: BaseAddr = %X, TimerNum = %d\n",
                N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM);

	XTmrCtr_LoadTimerCounterReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM);

		if (_DEBUG) xil_printf("Finalizing Control Status Register: BaseAddr = %X, TimerNum = %d, Value = %X (without LOAD_MASK)\n",
                N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, (ctl & ~XTC_CSR_LOAD_MASK));

	XTmrCtr_SetControlStatusReg(N4IO_PWM_CLK_BASEADDR, N4IO_PWM_CLK_TIMER_NUM, (ctl & ~XTC_CSR_LOAD_MASK));


	// and start it
		if (_DEBUG) xil_printf("Executing XTmrCTR_Start");

	XTmrCtr_Start(&N4IO_TimerInst, N4IO_PWM_CLK_TIMER_NUM);
	return XST_SUCCESS;
}

/**
 * do_init() - initializes the embedded system peripherals
 *
 * @brief This function initializes the AXI peripherals and sets up for interrupt handling.  Interrupts
 * are enabled/disabled in main() or other functions.  When this function exits the peripherals have
 * been initialized but interrupts are left disabled
 *
 * @return			XST_Success if the timer is initialized.  XST_FAILURE if it is not
 *
 * @note:  Digilent PWM Analyzer is a low level driver and does not need to be initialized
 */
int do_init(void) {
    if (_DEBUG) xil_printf("Entering do_init...\r");
    Xil_Out32(XPAR_PWM_ANALYZER_0_S00_AXI_BASEADDR + 0x08, 1); // Enable Red
    Xil_Out32(XPAR_PWM_ANALYZER_1_S00_AXI_BASEADDR + 0x08, 1); // Enable Green
    Xil_Out32(XPAR_PWM_ANALYZER_2_S00_AXI_BASEADDR + 0x08, 1); // Enable Blue

    uint32_t status; // status from Xilinx Lib calls

    // Initialize the RGB PWM clock to Nexys4IO
    if (_DEBUG) xil_printf("Initializing RGB PWM clock...\r");
    status = N4IO_RGB_timer_initialize();
    if (status != XST_SUCCESS) {
        if (_DEBUG) xil_printf("RGB PWM clock initialization failed!\r");
        return XST_FAILURE;
    }
    if (_DEBUG) xil_printf("RGB PWM clock initialized successfully.\r");

    // Initialize the Nexys4 driver
    if (_DEBUG) xil_printf("Initializing Nexys4 driver...\r");
    status = NX4IO_initialize(N4IO_BASEADDR);
    if (status != XST_SUCCESS) {
        if (_DEBUG) xil_printf("Nexys4 driver initialization failed!\r");
        return XST_FAILURE;
    }
    if (_DEBUG) xil_printf("Nexys4 driver initialized successfully.\r");

    // Initialize the interrupt controller
    if (_DEBUG) xil_printf("Initializing interrupt controller...\r");
    status = XIntc_Initialize(&INTC_Inst, INTC_DEVICE_ID);
    if (status != XST_SUCCESS) {
        if (_DEBUG) xil_printf("Interrupt controller initialization failed!\r");
        return XST_FAILURE;
    }
    if (_DEBUG) xil_printf("Interrupt controller initialized successfully.\r");

    // Connect the interrupt handlers to the interrupts
    if (_DEBUG) xil_printf("Connecting interrupt handler...\r");
    status = XIntc_Connect(&INTC_Inst, FIT_INTR_NUM, (XInterruptHandler)FIT_Handler, (void *)0);
    if (status != XST_SUCCESS) {
        if (_DEBUG) xil_printf("Failed to connect interrupt handler!\r");
        return XST_FAILURE;
    }
    if (_DEBUG) xil_printf("Interrupt handler connected successfully.\r");

    // Start the interrupt controller
    if (_DEBUG) xil_printf("Starting interrupt controller in REAL mode...\r");
    status = XIntc_Start(&INTC_Inst, XIN_REAL_MODE);
    if (status != XST_SUCCESS) {
        if (_DEBUG) xil_printf("Interrupt controller start failed!\r");
        return XST_FAILURE;
    }
    if (_DEBUG) xil_printf("Interrupt controller started successfully.\r");

    // Enable interrupts
    if (_DEBUG) xil_printf("Enabling interrupts...\r");
    XIntc_Enable(&INTC_Inst, FIT_INTR_NUM);
    if (_DEBUG) xil_printf("Interrupts enabled.\r");

    if (_DEBUG) xil_printf("do_init completed successfully.\r");
    return XST_SUCCESS;
}


/********** Helper functions **********/

/**
 * swizzleBtns() - formats the btns register from Nexys4IO for easy processing
 *
 * @brief
 * rearranges the bits from the Nexys4IO register {3'b0, 1'b0, BTNU(BTN0), BTND(BTN3), BTNL(BTN2), BTNR(BTN1)}
 * to {BTND(BTN3), BTNL(BTN2), BTNR(BTN1), BTNU(BTN0)}
 *
 * @param btns	button vector returned by Nexys4IO driver
 * @return 		swizzled buttons
 */
uint8_t swizzleBtns(uint8_t btns) {
	uint8_t btnd, btnl, btnr, btnu;		// individual buttons
	uint8_t b;							// swizzled buttons vector

    btnu = (btns & 0x08) >> 3;
    btnd = (btns & 0x04) >> 2;
    btnl = (btns & 0x02) >> 1;
	btnr = (btns & 0x01) >> 0;
	b = (btnd << 3) | (btnl << 2) | (btnr << 1) | (btnu << 0);
	return b;
}


/****************************************************************************/
/**
 * nexys4io_selfTest() - performs a self test on the NexysA7 peripheral
 *
 * @brief This is mostly a visual test to confirm that the 7-segment display and
 * RGB LEDs hardware and drivers are operating correctly.  The test does the following:
 *	o sends pattern(s) to the LEDs on the board
 *	o Writes a message on the 7-segment display
 *	o individually lights the RGB LEDs
 *	o sets the RGB2 LED to several values that can be observed
 *	o Turns off the LEDs and blanks the 7-segment digits and decimal points
 */
 void nexys4io_selfTest(void) {
	 XTmrCtr_Enable(&N4IO_TimerInst, N4IO_PWM_CLK_TIMER_NUM);

	xil_printf("Starting Nexys4IO self test...\r\n");

	xil_printf("\tcheck functionality of LEDs\r\n");
	uint16_t ledvalue = 0x0001;
	do {
		NX4IO_setLEDs(ledvalue);
		usleep(250 * 1000);
		ledvalue = ledvalue << 1;
	} while (ledvalue != 0);

	xil_printf("\tcheck functionality of 7-segment display\r\n");
	// set the display digits to -ECE544- and turn off
	// the decimal points using the "raw" set functions.
	NX4IO_SSEG_setSSEG_DATA(SSEGHI, 0x0058E30E);
	NX4IO_SSEG_setSSEG_DATA(SSEGLO, 0x00144116);
	usleep(2000 * 1000);

	xil_printf("\tcheck functionality of the RGB2 LED\n\r");
	// RGB2 is controlled by Nexys4IO
	NX4IO_RGBLED_setChnlEn(RGB2, true, true, true);
	NX4IO_RGBLED_setChnlEn(RGB1, true, true, true);

	xil_printf("\t\tRGB2 segments set to {{99%%, 00%%, 00%%} duty cycle - display RED\n\r");
	NX4IO_RGBLED_setDutyCycle(RGB2, 255, 0, 0);
	usleep(2000 * 1000);

	xil_printf("\t\tRGB2 segments set to {{00%%, 50%%, 00%%} duty cycle - display Green\n\r");
	NX4IO_RGBLED_setDutyCycle(RGB2, 0, 255, 0);
	usleep(2000 * 1000);

	xil_printf("\t\tRGB2 segments set to {{00%%, 00%%, 25%%} duty cycle - display Blue\n\r");
	NX4IO_RGBLED_setDutyCycle(RGB2, 0, 0, 64);
	usleep(2000 * 1000);

	xil_printf("\t\tRGB2 segments set to {{50%%, 12%%, 25%%} duty cycle - display Purplish-ish\n\r");
    NX4IO_RGBLED_setDutyCycle(RGB2, 255, 32, 64);
	usleep(2000 * 1000);

	uint32_t rgb1_cntrl = NX4IO_RGBLED_getRGB_CNTRL(RGB1);
	xil_printf("RGB1 Control Register: 0x%08X\n", rgb1_cntrl);

	Xil_Out32(N4IO_BASEADDR + NEXYS4IO_RGB1_DATA_OFFSET, 0x00FF0000); // Full RED
	usleep(2000 * 1000);
	Xil_Out32(N4IO_BASEADDR + NEXYS4IO_RGB1_DATA_OFFSET, 0x0000FF00); // Full GREEN
	usleep(2000 * 1000);
	Xil_Out32(N4IO_BASEADDR + NEXYS4IO_RGB1_DATA_OFFSET, 0x000000FF); // Full BLUE
	usleep(2000 * 1000);

	// turn off LEDs, display and RGB LEDs
	NX410_SSEG_setAllDigits(SSEGLO, CC_BLANK, CC_BLANK, CC_BLANK, CC_BLANK, DP_NONE);
	NX410_SSEG_setAllDigits(SSEGHI, CC_BLANK, CC_BLANK, CC_BLANK, CC_BLANK, DP_NONE);
    NX4IO_setLEDs(0x0000);

	// Turn off RGB2
	NX4IO_RGBLED_setDutyCycle(RGB2, 1, 1, 1);
	xil_printf("...Nexys4IO self test complete\r\n");
	return;
 }
